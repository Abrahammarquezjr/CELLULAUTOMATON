<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CELLULAUTOMATON</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0f;
    color: #e0e0ff;
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    overflow-x: hidden;
  }

  h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(16px, 3.5vw, 26px);
    letter-spacing: 6px;
    background: linear-gradient(90deg, #ff00ea, #00ffad, #ffef00, #00c3ff, #ff00ea);
    background-size: 300% 100%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: shimmer 6s linear infinite;
    margin-bottom: 20px;
    text-align: center;
  }

  @keyframes shimmer {
    0%   { background-position: 0% 50%; }
    100% { background-position: 300% 50%; }
  }

  .canvas-wrap {
    position: relative;
    border: 1px solid #ffffff22;
    box-shadow:
      0 0 40px 8px #ff00ea55,
      0 0 80px 20px #00ffad33,
      0 0 140px 40px #00c3ff22,
      0 0 200px 60px #ffef0011;
    background: #000;
  }

  canvas {
    display: block;
    image-rendering: pixelated;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 16px;
    justify-content: center;
    max-width: 600px;
  }

  button {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    letter-spacing: 2px;
    padding: 8px 16px;
    background: transparent;
    border: 1px solid #ffffff33;
    color: #fff;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.15s;
  }

  button:hover {
    background: #ffffff11;
    border-color: #ff00ea88;
    box-shadow: 0 0 12px #ff00ea44;
    color: #ff00ea;
  }

  .info-row {
    display: flex;
    gap: 24px;
    margin-top: 12px;
    font-size: 11px;
    color: #444;
    letter-spacing: 1px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .info-row span { color: #ffffff55; }

  .speed-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-top: 10px;
    font-size: 11px;
    color: #444;
    letter-spacing: 1px;
  }

  input[type=range] {
    -webkit-appearance: none;
    width: 120px;
    height: 2px;
    background: #ffffff22;
    outline: none;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px; height: 14px;
    border-radius: 50%;
    background: #ff00ea;
    cursor: pointer;
  }
</style>
</head>
<body>

<h1>CELLULAUTOMATON</h1>

<div class="canvas-wrap">
  <canvas id="ca" width="500" height="500"></canvas>
</div>

<div class="controls">
  <button id="btnReset">RESET</button>
  <button id="btnHue">RANDOM HUE</button>
  <button id="btnSave">SAVE PNG</button>
</div>

<div class="speed-row">
  SPEED <input type="range" id="speedSlider" min="1" max="20" value="8">
  <span id="speedVal">8</span>fps
</div>

<div class="info-row">
  <div>SEED <span id="infoSeed">—</span></div>
  <div>LEVEL <span id="infoLevel">0</span></div>
  <div>STATES <span id="infoStates">2</span></div>
</div>

<script>
const canvas = document.getElementById('ca');
const ctx    = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const CELL = 5;
const COLS = W / CELL;
const ROWS = H / CELL;

let seed     = Math.floor(Math.random() * 99999999);
let rule     = [];
let grid     = [];
let level    = 0;
let fps      = 8;
let lastTime = 0;
let hueShift = 0;

// Radial distance map for ripple wave coloring
const distMap = new Float32Array(COLS * ROWS);
(function(){
  const maxD = Math.sqrt((COLS/2)**2 + (ROWS/2)**2);
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      distMap[r * COLS + c] = Math.sqrt((c - COLS/2)**2 + (r - ROWS/2)**2) / maxD;
})();

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function generateRule(s) {
  const rng = mulberry32(s);
  const r   = Array.from({length: 9}, () => rng() < 0.45 ? 1 : 0);
  r[2] = 1; r[3] = 1;
  return r;
}

function initGrid(s) {
  seed     = s;
  rule     = generateRule(seed);
  level    = 0;
  hueShift = Math.random() * 360;
  const rng = mulberry32(seed + 1);
  grid = Array.from({length: ROWS}, () => new Uint8Array(COLS));
  const cx = Math.floor(COLS / 2), cy = Math.floor(ROWS / 2);
  for (let dy = -3; dy <= 3; dy++)
    for (let dx = -3; dx <= 3; dx++)
      if (rng() < 0.5) grid[cy + dy][cx + dx] = 1;
}

let neighborSum = [];
function stepGrid() {
  const next    = grid.map(r => new Uint8Array(r));
  const nextSum = Array.from({length: ROWS}, () => new Uint8Array(COLS));
  for (let r = 1; r < ROWS - 1; r++)
    for (let c = 1; c < COLS - 1; c++) {
      const sum =
        grid[r-1][c-1] + grid[r-1][c] + grid[r-1][c+1] +
        grid[r  ][c-1]                + grid[r  ][c+1] +
        grid[r+1][c-1] + grid[r+1][c] + grid[r+1][c+1];
      next[r][c]    = rule[sum];
      nextSum[r][c] = sum;
    }
  grid        = next;
  neighborSum = nextSum;
  level++;
  hueShift = (hueShift + 2.5) % 360;
}

const _rgb = [0,0,0];
function hslRGB(h, s, l) {
  s /= 100; l /= 100;
  const a = s * Math.min(l, 1 - l);
  const f = n => { const k = (n + h/30) % 12; return l - a * Math.max(-1, Math.min(k-3, Math.min(9-k, 1))); };
  _rgb[0] = f(0)*255|0; _rgb[1] = f(8)*255|0; _rgb[2] = f(4)*255|0;
}

function render() {
  const img  = ctx.createImageData(W, H);
  const data = img.data;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const dist  = distMap[r * COLS + c];
      const alive = grid[r][c];
      let rr, gg, bb;
      if (alive) {
        const s = neighborSum[r] ? neighborSum[r][c] : 0;
        hslRGB((hueShift + dist * 180 + s * 28) % 360, 100, 28 + s * 7);
        rr = _rgb[0]; gg = _rgb[1]; bb = _rgb[2];
      } else {
        let liveN = 0;
        if (r > 0      && grid[r-1][c]) liveN++;
        if (r < ROWS-1 && grid[r+1][c]) liveN++;
        if (c > 0      && grid[r][c-1]) liveN++;
        if (c < COLS-1 && grid[r][c+1]) liveN++;
        if (liveN > 0) {
          hslRGB((hueShift + dist * 180 + 40) % 360, 90, liveN * 6);
          rr = _rgb[0]; gg = _rgb[1]; bb = _rgb[2];
        } else {
          rr = 0; gg = 0; bb = 0;
        }
      }
      for (let dy = 0; dy < CELL; dy++)
        for (let dx = 0; dx < CELL; dx++) {
          const px = ((r * CELL + dy) * W + (c * CELL + dx)) * 4;
          data[px] = rr; data[px+1] = gg; data[px+2] = bb; data[px+3] = 255;
        }
    }
  }
  ctx.putImageData(img, 0, 0);
}

function updateInfo() {
  document.getElementById('infoSeed').textContent   = seed;
  document.getElementById('infoLevel').textContent  = level;
  document.getElementById('infoStates').textContent = 2;
}

// Runs forever — no pause, no stop
function loop(ts) {
  requestAnimationFrame(loop);
  if (ts - lastTime < 1000 / fps) return;
  lastTime = ts;
  stepGrid();
  render();
  updateInfo();
  const alive = grid.some(r => r.some(v => v));
  if (!alive || level > 500) {
    seed = Math.floor(Math.random() * 99999999);
    initGrid(seed);
  }
}

document.getElementById('btnReset').onclick = () => {
  seed = Math.floor(Math.random() * 99999999);
  initGrid(seed);
  render();
  updateInfo();
};

document.getElementById('btnHue').onclick = () => {
  hueShift = Math.random() * 360;
  render();
};

document.getElementById('btnSave').onclick = () => {
  const a = document.createElement('a');
  a.download = `cellulautomaton-${seed}-lvl${level}.png`;
  a.href = canvas.toDataURL();
  a.click();
};

document.getElementById('speedSlider').oninput = function() {
  fps = +this.value;
  document.getElementById('speedVal').textContent = fps;
};

initGrid(seed);
render();
updateInfo();
requestAnimationFrame(loop);
</script>
</body>
</html>
